
/*
 * This is a recursive function
 *
 * Input: 
 * 	A set S_new subset of S, containing elements that have not been processed yet.
 *	A set S_old subset of S, containing elements that have already been processed.
 *	A map Operation : S -> S
 *
 *
 * Output: A set S' subset of S such that Operation(S') = S'.
 */
intrinsic generatedSet(S_new :: SetEnum[RngIntElt], S_old :: SetEnum[RngIntElt], Operation :: Map[SetCart, SeqEnum[RngIntElt]]) -> SetEnum[RngIntElt]
{ It recursively finds the set generated by applying a function 'Operation' to a set S_new until no new elements are returned }
        
	// Stopping condition: If there is no element to be processed, 
	// we are done and can return all the elements we have processed thus far.
	if IsEmpty(S_new) then 
		return S_old;
	end if;
	
	
    newResults := {  };

	for old in S_old do
		for new in S_new do
			Include(~newResults, Operation(<old, new>));
			Include(~newResults, Operation(<new, old>));
		end for;
	end for;
	
	for new1 in S_new do
		for new2 in S_new do
			Include(~newResults, Operation(<new1, new2>));
		end for;
	end for;
	/*
	 * 'A join B' is a way to obtain the union A U B of sets A and B in MAGMA
	 * S_old is redefined to be S_new U S_old since the elements in S_new have been processed
	 *
	 * 'A diff B' is a way to obtain the set difference A \ B of sets A and B in MAGMA
	 * S_new is redefined to be newResults \ S_old
	 * We are effectively removing what we have already seen from the list of all new-found elements
	 */
	S_old := (S_new join S_old);    
	S_new := newResults diff S_old;
	
	// Recursive call 
	return generatedSet(S_new, S_old, Operation);
end intrinsic;


/*
 * Input: 
 * 	A quandle Q = (X, *).
 *	A subset S of X closed under *.
 *
 *
 * Output: A Quandle Q' subquandle of Q
 */
intrinsic generatedSubquandle(Q :: Qndl, S :: SetEnum) -> Qndl
{ Finds the subquandle Q' within the quandle Q with underylying set S }
	error if Universe(Q`Set) ne Universe(S), "S is not a subset of of the underlying set of Q.";
	for x in S do
		error if x notin Q`Set, "S is not a subset of of the underlying set of Q.";
	end for;

	graph := [ <<x,y>, Q`Operation(<x,y>)> : x,y in S];
	codomain := [ x[2] : x in graph ];
	error if not IsSubsequence(codomain, Setseq(S) : Kind := "Setwise"), "S is not closed under the quandle operation.";
	operation := map< car<S,S> -> codomain | graph >;
    return Quandle(S, operation);
end intrinsic;



/*
 * Input: 
 *  uSet : The domain of the operation as a sorted sequence.
 * 	B : A square sequence of sequences representing a binary function from uSet x uSet  to N.
 *  expected : a boolean flag indicating whether the function can expect to be working with {1 .. n} as domain , for some n in N, or not. 
 *
 * Output: The map induced by B. 
 */
intrinsic MappifyOperation(uSet :: SeqEnum, B :: SeqEnum[SeqEnum[RngIntElt]], expected :: BoolElt) -> Map[SetCart, SeqEnum[RngIntElt]]
{ Constructs the Map induced by the binary operation B }
	
	if expected then 
		graph := [ <<x,y>, B[x,y]> : x,y in uSet ];
	else 
		graph := [ <<x,y>, B[Index(uSet, x),Index(uSet, y)]> : x,y in uSet ];
	end if;
	
	
	return map< car<uSet,uSet> -> B[1] | graph >;

end intrinsic;












