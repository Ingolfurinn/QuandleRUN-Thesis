
/*
 * This is a recursive function
 *
 * Input: 
 * 	A set S_new subset of S, containing elements that have not been processed yet.
 *	A set S_old subset of S, containing elements that have already been processed.
 *	A map Operation : S -> S
 *
 *
 * Output: A set S' subset of S such that Operation(S') = S'.
 */
intrinsic generatedSet(S_new :: SetIndx[RngIntElt], S_old :: SetIndx[RngIntElt], Operation :: Map[SetCart, SeqEnum[RngIntElt]]) -> SetEnum[RngIntElt]
{ It recursively finds the set generated by applying a function 'Operation' to a set S_new until no new elements are returned }
        
	// Stopping condition: If there is no element to be processed, 
	// we are done and can return all the elements we have processed thus far.
	if IsEmpty(S_new) then 
		return S_old;
	end if;
	
	
    newResults := {  };

	for old in S_old do
		for new in S_new do
			Include(~newResults, Operation(<old, new>));
			Include(~newResults, Operation(<new, old>));
		end for;
	end for;
	
	for new1 in S_new do
		for new2 in S_new do
			Include(~newResults, Operation(<new1, new2>));
		end for;
	end for;
	/*
	 * 'A join B' is a way to obtain the union A U B of sets A and B in MAGMA
	 * S_old is redefined to be S_new U S_old since the elements in S_new have been processed
	 *
	 * 'A diff B' is a way to obtain the set difference A \ B of sets A and B in MAGMA
	 * S_new is redefined to be newResults \ S_old
	 * We are effectively removing what we have already seen from the list of all new-found elements
	 */
	S_old := (S_new join S_old);    
	S_new := newResults diff S_old;
	
	// Recursive call 
	return generatedSet(S_new, S_old, Operation);
end intrinsic;


/*
 * This is a recursive function
 *
 * Input: 
 * 	A set S_new subset of S, containing elements that have not been processed yet.
 *	A set S_old subset of S, containing elements that have already been processed.
 *	A matrix representing a map Operation : S -> S
 *
 *
 * Output: A set S' subset of S such that Operation(S') = S'.
 */
intrinsic generatedSet(S_new :: SetIndx[RngIntElt], S_old :: SetIndx[RngIntElt], Operation :: SeqEnum[SeqEnum[RngIntElt]]) -> SetEnum[RngIntElt]
{ It recursively finds the set generated by applying a function 'Operation' to a set S_new until no new elements are returned }
        
	// Stopping condition: If there is no element to be processed, 
	// we are done and can return all the elements we have processed thus far.
	if IsEmpty(S_new) then 
		return S_old;
	end if;
	
	newResults := {@  @};

	for indexOld := 1 to #S_old do
		for indexNew := 1 to #S_new do
			old := S_old[indexOld];
			new := S_new[indexNew];
			Include(~newResults, Operation[old][new]);
			Include(~newResults, Operation[new][old]);
		end for;
	end for;
	
	for indexNew1 := 1 to #S_new do
		new1 := S_new[indexNew1];
		for indexNew2 := 1 to #S_new do
			new2 := S_new[indexNew2];
			Include(~newResults, Operation[new1][new2]);
		end for;
	end for;
	/*
	 * 'A join B' is a way to obtain the union A U B of sets A and B in MAGMA
	 * S_old is redefined to be S_new U S_old since the elements in S_new have been processed
	 *
	 * 'A diff B' is a way to obtain the set difference A \ B of sets A and B in MAGMA
	 * S_new is redefined to be newResults \ S_old
	 * We are effectively removing what we have already seen from the list of all new-found elements
	 */
	S_old := (S_new join S_old);    
	S_new := newResults diff S_old;
	
	// Recursive call 
	return generatedSet(S_new, S_old, Operation);
end intrinsic;

/*
 * Input: 
 * 	A quandle Q = (X, *).
 *	A set S subset of X.
 *
 *
 * Output: A Quandle Q' subquandle of Q
 */
intrinsic generatedSubquandle(Q :: Qndl, S :: SetEnum[RngIntElt]) -> Qndl
{ Finds the subquandle generated by S within the quandle Q }
	
	// Defines the Operation for the (sub)Quandle
    Subquandle_Operation := Q`Operation;

	// Finds the underlying set of the (sub)Quandle
    Subquandle_set := generatedSet(S, {}, Q`Operation);
	

    return Quandle(Subquandle_set, Subquandle_Operation);
end intrinsic;

/*
 * Input: 
 * 	A quandle Qa = (X, ^).
 *	A quandle Qb = (X, *).
 *  permutation_sigma, a sequence representing a permutation of X.
 *
 *
 * Output: True if Q_Sub is a subquandle of Q, False otherwise.
 */        
intrinsic isomorphicByPermutation(Qa :: Qndl, Qb :: Qndl, permutation_sigma :: SeqEnum[RngIntElt] ) -> BoolElt
{ Tests whether Qa is isomorphic to Qb by permutation permutation_sigma of its underlying set X }

	M := QuandleMatrix(Qa);
	N := QuandleMatrix(Qb);

	Ps, sigma_M, TPs := getPermutationMatrices(permutation_sigma,M);
	
	/*
	 * Left multiplication by Mxs[3](the inverse of the permutation matrix Mxs[1] reorders the rows of the matrix)
	 * Left multiplication by Mxs[1](the permutation matrix reorders the columns of the matrix)
	 * Mxs[2] is the sigma(M)
	 */
	Prtd := TPs * sigma_M * Ps;
	
	// Prtd is isomorphic to M but here we check whether Prtd is equal to N and thus M and N are isomorphic.
	if Prtd eq N then
		return true;
	end if;

	return false;

end intrinsic;


/*
 * Input: 
 * 	A square sequence of sequences representing a binary function from {1, ..., n} x {1, ..., n}  to N.
 *
 *
 * Output: The map induced by the sequence. 
 */
intrinsic MappifyOperation(B :: SeqEnum[SeqEnum[RngIntElt]]) -> Map[SetCart, SeqEnum[RngIntElt]]
{ Constructs the Map induced by the binary operation B }
	
	uSet := [1 .. #B];
	graph := [ <<x,y>, B[x,y]> : x,y in uSet ];
	return map< car<uSet,uSet> -> uSet | graph >;

end intrinsic;


/*
 * Input: 
 * 	A quandle Q = (X, *), represented by a square sequence of sequences.
 *	A set S subset of X.
 *
 *
 * Output: A Quandle Q' subquandle of Q
 */
intrinsic generatedSubuniverseCorollary5_5(Q :: SeqEnum[SeqEnum[RngIntElt]], S :: SetEnum[RngIntElt]) -> SetIndx[RngIntElt]
{ Finds the subquandle generated by S within the quandle Q }
	
	
	Lss := [];

	S_X := Sym(#Q);

	for element in S do
		Append(~Lss, S_X ! Q[element] );
	end for;
	
	M := sub<S_X | Lss >;

	Subquandle_set := &join {x^M : x in S};

    return Subquandle_set;
end intrinsic;




/*
 * CREAM + NiccolÃ² Carrivale
 * Input: Let Q be a quandle, for some n in N.
 * F : The multiplication table of Q, represented by a square sequence of sequences. 
 *
 * Output: Computes all the subuniverses of the quandle Q, represented by the square sequence of sequences F.
 */
intrinsic SubuniversesCorollary5_5(F :: SeqEnum[SeqEnum[RngIntElt]]) -> SetIndx[SetIndx[RngIntElt]]
{ Returns all the subuniverses of quandle Q }

	valid := Subsets({x : x in F[1]},2);	
	subs := {@ {@ x  : x in F[1] @} @};
	for x in F[1] do 
		Include(~subs, {@ x @});
	end for;

	while not IsEmpty(valid) do

		set := Rep(valid);
		Exclude(~valid,set);
		genSet := generatedSubuniverseCorollary5_5(F,set);
		if #genSet lt (#F-1) then 
			Include(~subs,genSet);
			for x in { x : x in F[1] | x notin genSet} do
				Include(~valid,Include(genSet,x));
			end for;
		end if;
	end while;
	
	return subs;

end intrinsic;









